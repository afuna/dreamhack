<html><head><title>XML::Atom::Server</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw " type="text/css" href="../../blkbluw_.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk " type="text/css" href="../../whtpurk_.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng " type="text/css" href="../../whtgrng_.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw " type="text/css" href="../../grygrnw_.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.13,
  using Pod::Simple::PullParser v3.13,
  under Perl v5.008008 at Mon Feb  7 00:00:16 2011 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SUBCLASSING'>SUBCLASSING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Request_Handling'>Request Handling</a>
    <li class='indexItem indexItem2'><a href='#Authentication'>Authentication</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Client_Request_Parameters'>Client Request Parameters</a>
    <li class='indexItem indexItem2'><a href='#Setting_up_the_Response'>Setting up the Response</a>
    <li class='indexItem indexItem2'><a href='#Processing_the_Request'>Processing the Request</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <li class='indexItem indexItem1'><a href='#ERROR_HANDLING'>ERROR HANDLING</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR_%26_COPYRIGHT'>AUTHOR &#38; COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::Atom::Server - A server for the Atom API</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package My::Server;
    use base qw( XML::Atom::Server );
    sub handle_request {
        my $server = shift;
        $server-&#62;authenticate or return;
        my $method = $server-&#62;request_method;
        if ($method eq &#39;POST&#39;) {
            return $server-&#62;new_post;
        }
        ...
    }

    my %Passwords;
    sub password_for_user {
        my $server = shift;
        my($username) = @_;
        $Passwords{$username};
    }

    sub new_post {
        my $server = shift;
        my $entry = $server-&#62;atom_body or return;
        ## $entry is an XML::Atom::Entry object.
        ## ... Save the new entry ...
    }

    package main;
    my $server = My::Server-&#62;new;
    $server-&#62;run;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><i>XML::Atom::Server</i> provides a base class for Atom API servers. It handles all core server processing, both the SOAP and REST formats of the protocol, and WSSE authentication. It can also run as either a mod_perl handler or as part of a CGI program.</p>

<p>It does not provide functions specific to any particular implementation, such as posting an entry, retrieving a list of entries, deleting an entry, etc. Implementations should subclass <i>XML::Atom::Server</i>, overriding the <i>handle_request</i> method, and handle all functions such as this themselves.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUBCLASSING"
>SUBCLASSING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Request_Handling"
>Request Handling</a></h2>

<p>Subclasses of <i>XML::Atom::Server</i> must override the <i>handle_request</i> method to perform all request processing. The implementation must set all response headers, including the response code and any relevant HTTP headers, and should return a scalar representing the response body to be sent back to the client.</p>

<p>For example:</p>

<pre>    sub handle_request {
        my $server = shift;
        my $method = $server-&#62;request_method;
        if ($method eq &#39;POST&#39;) {
            return $server-&#62;new_post;
        }
        ## ... handle GET, PUT, etc
    }
    
    sub new_post {
        my $server = shift;
        my $entry = $server-&#62;atom_body or return;
        my $id = save_this_entry($entry);  ## Implementation-specific
        $server-&#62;response_header(Location =&#62; $server-&#62;uri . &#39;/entry_id=&#39; . $id);
        $server-&#62;response_code(201);
        $server-&#62;response_content_type(&#39;application/x.atom+xml&#39;);
        return serialize_entry($entry);    ## Implementation-specific
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Authentication"
>Authentication</a></h2>

<p>Servers that require authentication for posting or retrieving entries or feeds should override the <i>password_for_user</i> method. Given a username (from the WSSE header), <i>password_for_user</i> should return that user&#39;s password in plaintext. This will then be combined with the nonce and the creation time to generate the digest, which will be compared with the digest sent in the WSSE header. If the supplied username doesn&#39;t exist in your user database or alike, just return <code>undef</code>.</p>

<p>For example:</p>

<pre>    my %Passwords = ( foo =&#62; &#39;bar&#39; );   ## The password for &#34;foo&#34; is &#34;bar&#34;.
    sub password_for_user {
        my $server = shift;
        my($username) = @_;
        $Passwords{$username};
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p><i>XML::Atom::Server</i> provides a variety of methods to be used by subclasses for retrieving headers, content, and other request information, and for setting the same on the response.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Client_Request_Parameters"
>Client Request Parameters</a></h2>

<ul>
<li>$server-&#62;uri
<p>Returns the URI of the Atom server implementation.</p>
</li>

<li>$server-&#62;request_method
<p>Returns the name of the request method sent to the server from the client (for example, <code>GET</code>, <code>POST</code>, etc). Note that if the client sent the request in a SOAP envelope, the method is obtained from the <i>SOAPAction</i> HTTP header.</p>
</li>

<li>$server-&#62;request_header($header)
<p>Retrieves the value of the HTTP request header <i>$header</i>.</p>
</li>

<li>$server-&#62;request_content
<p>Returns a scalar containing the contents of a POST or PUT request from the client.</p>
</li>

<li>$server-&#62;request_param($param)
<p><i>XML::Atom::Server</i> automatically parses the PATH_INFO sent in the request and breaks it up into key-value pairs. This can be used to pass parameters. For example, in the URI</p>

<pre>    http://localhost/atom-server/entry_id=1</pre>

<p>the <i>entry_id</i> parameter would be set to <code>1</code>.</p>

<p><i>request_param</i> returns the value of the value of the parameter <i>$param</i>.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Setting_up_the_Response"
>Setting up the Response</a></h2>

<ul>
<li>$server-&#62;response_header($header, $value)
<p>Sets the value of the HTTP response header <i>$header</i> to <i>$value</i>.</p>
</li>

<li>$server-&#62;response_code([ $code ])
<p>Returns the current response code to be sent back to the client, and if <i>$code</i> is given, sets the response code.</p>
</li>

<li>$server-&#62;response_content_type([ $type ])
<p>Returns the current <i>Content-Type</i> header to be sent back to the client, and <i>$type</i> is given, sets the value for that header.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Processing_the_Request"
>Processing the Request</a></h2>

<ul>
<li>$server-&#62;authenticate
<p>Attempts to authenticate the request based on the authentication information present in the request (currently just WSSE). This will call the <i>password_for_user</i> method in the subclass to obtain the cleartext password for the username given in the request.</p>
</li>

<li>$server-&#62;atom_body
<p>Returns an <i>XML::Atom::Entry</i> object containing the entry sent in the request.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<p>Once you have defined your server subclass, you can set it up either as a CGI program or as a mod_perl handler.</p>

<p>A simple CGI program would look something like this:</p>

<pre>    #!/usr/bin/perl -w
    use strict;

    use My::Server;
    my $server = My::Server-&#62;new;
    $server-&#62;run;</pre>

<p>A simple mod_perl handler configuration would look something like this:</p>

<pre>    PerlModule My::Server
    &#60;Location /atom-server&#62;
        SetHandler perl-script
        PerlHandler My::Server
    &#60;/Location&#62;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ERROR_HANDLING"
>ERROR HANDLING</a></h1>

<p>If you wish to return an error from <i>handle_request</i>, you can use the built-in <i>error</i> method:</p>

<pre>    sub handle_request {
        my $server = shift;
        ...
        return $server-&#62;error(500, &#34;Something went wrong&#34;);
    }</pre>

<p>This will be returned to the client with a response code of 500 and an error string of <code>Something went wrong</code>. Errors are automatically serialized into SOAP faults if the incoming request is enclosed in a SOAP envelope.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_&#38;_COPYRIGHT"
>AUTHOR &#38; COPYRIGHT</a></h1>

<p>Please see the <i>XML::Atom</i> manpage for author, copyright, and license information.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
